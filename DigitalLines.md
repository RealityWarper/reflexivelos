# Introduction #

One of the biggest problems with line of sight programs is defining what line of sight is in the first place. Many important questions come up:
  * are the players and objects points, or two dimensional squares?
  * if they are points, are they at the bottom of the square, or in the center?
  * if two parts of the map are connected diagonally, can I see through the cracks?
  * if the player can see a monster, can the monster necessarily see the player?
  * what exactly is a straight line?

We'll start with the last question.

# Digital Lines #

## Chain Codes ##

To simplify the discussion, we'll discuss lines with slope between 0 and 1. If we think of a line in terms of the squares of the grid it passes through, we can encode the line as a sequence of 0s and 1s as follows: if the line moves to the right, we write down a 0, and if it moves diagonally up and to the right, we write down a 1.

Examples:

```
         #
       ##
    ### 
  ##    
##
```
corresponds to
```
010100101
```

while

```
     #####
    #   
   #    
  #     
##      
```
corresponds to
```
011110000
```

This method of representing digital lines is called chain coding.

## Balanced Words ##

Now the question arises: which sequences of 0s and 1s correspond to actual lines? The first example made a pretty good line, while the second one is quite clearly not a line. Just looking at the encoding of the second line, we can see that it had four 1s in a row, and later, had four 0s in a row. On the other hand, the first example had "very evenly distributed" 0s and 1s. We would like to formalize the intuitive concept of "very evenly distributed".

A _binary word_ is a sequence of 0s and 1s. The _height_ of a word is defined as the number of 1s in the word. A _factor_ of a word is basically a substring of it (_subword_ has a different meaning). A _balanced word_ is a word such that for any two factors of the same length, their height differs by at most one. The second example is not balanced, because it contains two factors - 1111 and 0000 - the first having height four and the second having height zero. On the other hand, the first example is balanced - for example, all factors of length three have height between one and two.

Now we're going to turn around and define a digital line as a line whose chain code is a balanced binary word.

## A complete list of Digital Lines ##

One way to generate digital lines is the Bresenham Line Drawing Algorithm. For a line of slope `p/q`, we keep a variable `offset`, and add `p` to `offset` at each step. If `offset` is less than `q`, we write down a 0, and if `offset` is more than or equal to `q`, we write down a 1 and subtract `q` from `offset`. The chain codes generated like this are guaranteed to be balanced, for obvious reasons.

But this might not give us all possible digital lines! Worse still, it isn't obvious that a digital line of length `n` generated from a fraction of the form, say, `2n/(3n+5)` won't give us a new line not generatable from fractions with smaller denominators.

Luckily, we do know that every digital line can be generated by using a slight modification to the Bresenham Algorithm, in which `offset` can be started off with any value between 0 and `q-1`. In fact, every digital line of length `n` can be described by a fraction `p/q` and an initial `offset`, with the denominator `q` equal to the minimal period of the word (a period of a word doesn't have to divide its length, for example, two is a period of 01010).

Alternatively, every digital line appears as a sub-line of something generated by Bresenham's Algorithm.

Examples:
```
n = 7, p = 2, q = 5, offset = 0
chain code: 0010100
     ###
   ##
###
```

```
n = 7, p = 2, q = 5, offset = 2
chain code: 0101001
       #
    ###
  ##
##
```

```
n = 7, p = 1, q = 4, offset = 2
chain code: 0100010
      ##
  ####
##
```

## Useful properties of Digital Lines ##
  * If there is a digital line connecting A to B, there is a digital line connecting B to A.
  * If two digital lines connect the same points A and B, their heights cannot differ by more than 1 at an intermediate point.
  * Two digital lines with the same height and length cannot "bend" around an obstruction and meet up later. This is what allows the line of sight algorithm to work on manifolds.

## Geometric Interpretation ##

"Great," you're thinking, "now we have this abstract definition of a digital line. But, geometrically, it's completely meaningless!" You point your finger at this so called "digital line" between `A` and `B` in fury:

```
     ####.B
   ###...##
####..####
#A..###
```

"There is no way you can get a line to pass through all those corners without bending it, or, worse, letting the line pass through the walls!"

It's OK. Calm down. I'm going to explain the geometry right now. The truth is, I hate sharp edges. In order to protect adventurers from cuts and scrapes, I beveled all of the corners of my dungeon. Since my adventurers (as well as monsters, items, etc.) are perfectly diamond shaped, this allows them to squeeze through corners perfectly! Also, I assume that the eyes of my adventurers can be located on whatever part of their diamond shaped bodies they like, and even the smallest glimpse of another diamond shaped being is enough to guess what they are.

It's a fun exercise to show that this geometrical interpretation is equivalent to the existence of digital lines connecting the two locations. (Hint: if you restrict to one octant, diamonds might as well be line segments)

One can also define a three dimensional version of digital lines (and even digital planes!), but I'm not sure how that would be interpreted geometrically (my guess is beveled cubes, but these are a little less intuitive than diamonds).

# Further Reading #

Here's a list of some useful papers on the subject:

  1. Digital straightness, a review. By Reinhard Klette and Azriel Rosenfeld.
  1. Discrete Straight Line Segments: Parameters, Primitives, and Properties. By Leo Dorst and Arnold W.M. Smeulders.
  1. On the Number of Digital Straight Line Segments. By Carlos A. Berenstein and David Lavine.
  1. Random Generation of Finite Sturmian Words. By Jean Berstel and Michel Pocchiola.